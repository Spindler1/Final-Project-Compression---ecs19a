
/*************************************************************************
 *  Compilation:  javac SchubsH.java
 *  Execution:    java SchubsH file1 file2 file3 ... OR java SchubsH <GLOB>
 *  Run Example:  java SchubsH ../src/SchubsHTests/test1.txt
 *                java SchubsH ../src/SchubsHTests/*.txt
 * 
 *  Description:  This program compresses a given file using Huffman encoding.
 * 
 *  Design: Huffman encoding is a widely used algorithm in data compression, 
 *          primarily focusing on lossless compression of data. The core idea behind Huffman 
 *          encoding is to assign variable-length codes to input characters, with shorter 
 *          codes assigned to more frequent characters and longer codes assigned to less frequent characters.
 *          This ensures that the most frequent characters are represented by the shortest bit sequences, 
 *          optimizing the overall compression ratio.
 *
 *   Trade Off:The algorithm begins by constructing a Huffman tree, which is a binary tree where each leaf node 
 *          represents a character along with its frequency in the input data. Then, starting with individual 
 *          characters as leaves, it repeatedly merges the two lowest frequency nodes into a new internal node 
 *          until only one node remains, which becomes the root of the tree. The binary encoding of each character 
 *          is determined by traversing the tree from the root to the leaf corresponding to that character, assigning '0' 
 *          for left branches and '1' for right branches.
 *
 *          Finally, the encoded data is generated by replacing each input character with its corresponding Huffman code.
 *          Since the most frequent characters have shorter codes, the resulting encoded data is more compact, leading to 
 *          efficient storage and transmission of information.
 * 
 *  Test Instructions: mvn test
 *   
 *  
 *  Ethan Spindler
 *  CS 375
 *  May 5 2024
 *  
 *
 *************************************************************************/
import java.io.*;
import java.util.*;

public class SchubsH {

    // alphabet size of extended ASCII
    private static final int R = 256;

    // Huffman trie node
    private static class Node implements Comparable<Node> {
        private final char ch;
        private final int freq;
        private final Node left, right;

        Node(char ch, int freq, Node left, Node right) {
            this.ch = ch;
            this.freq = freq;
            this.left = left;
            this.right = right;
        }

        // is the node a leaf node?
        private boolean isLeaf() {
            assert (left == null && right == null) || (left != null && right != null);
            return (left == null && right == null);
        }

        // compare, based on frequency
        public int compareTo(Node that) {
            return this.freq - that.freq;
        }
    }

    // compress bytes from standard input and write to standard output
    public static void compress(String filename, String filename2) {
        try {
            // read the input file
            FileInputStream fis = new FileInputStream(filename);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            byte[] buffer = new byte[1024];
            int bytesRead;
            while ((bytesRead = fis.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesRead);
            }
            fis.close();

            byte[] input = baos.toByteArray();

            // tabulate frequency counts
            int[] freq = new int[R];
            for (int i = 0; i < input.length; i++)
                freq[input[i] & 0xFF]++;

            // build Huffman trie
            Node root = buildTrie(freq);

            // build code table
            String[] st = new String[R];
            buildCode(st, root, "");

            // create output stream for writing compressed file
            FileOutputStream fos = new FileOutputStream(filename2);
            ObjectOutputStream oos = new ObjectOutputStream(fos);

            // write trie for decoder
            writeTrie(root, oos);

            // write number of bytes in original uncompressed message
            oos.writeInt(input.length);

            // use Huffman code to encode input and write to compressed file
            for (int i = 0; i < input.length; i++) {
                String code = st[input[i] & 0xFF];
                for (int j = 0; j < code.length(); j++) {
                    if (code.charAt(j) == '0') {
                        oos.writeBoolean(false);
                    } else if (code.charAt(j) == '1') {
                        oos.writeBoolean(true);
                    } else
                        throw new RuntimeException("Illegal state");
                }
            }

            // flush and close output stream
            oos.flush();
            oos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // build the Huffman trie given frequencies
    private static Node buildTrie(int[] freq) {
        // initialize priority queue with singleton trees
        PriorityQueue<Node> pq = new PriorityQueue<>();
        for (char i = 0; i < R; i++)
            if (freq[i] > 0)
                pq.add(new Node(i, freq[i], null, null));

        // merge two smallest trees
        while (pq.size() > 1) {
            Node left = pq.poll();
            Node right = pq.poll();
            Node parent = new Node('\0', left.freq + right.freq, left, right);
            pq.add(parent);
        }
        return pq.poll();
    }

    // write bitstring-encoded trie to output stream
    private static void writeTrie(Node x, ObjectOutputStream oos) throws IOException {
        if (x.isLeaf()) {
            oos.writeBoolean(true);
            oos.writeChar(x.ch);
            return;
        }
        oos.writeBoolean(false);
        writeTrie(x.left, oos);
        writeTrie(x.right, oos);
    }

    // make a lookup table from symbols and their encodings
    private static void buildCode(String[] st, Node x, String s) {
        if (!x.isLeaf()) {
            buildCode(st, x.left, s + '0');
            buildCode(st, x.right, s + '1');
        } else {
            st[x.ch] = s;
        }
    }

    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println("    Usage: java SchubsH file1 file2 file3 ... OR java SchubsH <GLOB>");
            System.out.println("    file1: file to be compressed");
            System.out.println("    file2: compressed file");
            System.out.println("    file3: file to be compressed ...");
            System.out.println("    Incorrect number of arguments.");
            throw new IllegalArgumentException("Incorrect number of arguments.");
        }
        for (int i = 0; i < args.length; i++) {
            File in = new File(args[i]);
            if (!in.exists()) {
                System.out.println("    File " + args[i] + " does not exist.");
                throw new IllegalArgumentException("File " + args[i] + " does not exist.");
            } else {
                String filename = args[i];
                String filename2 = filename + ".hh";
                compress(filename, filename2);
            }
        }
    }
}
